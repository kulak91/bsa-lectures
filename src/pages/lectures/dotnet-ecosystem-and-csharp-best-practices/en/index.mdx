---
orderId: 4
author: "Ivan Hedz"
title: ".NET ecosystem and C# best practices"
description: "Ivan makes an overview of <strong>.NET</strong> ecosystem, tell us deep insides about <strong>–°#</strong> and to top it all off tells about clean code principals."
keywords: ["dotnet", "ecosystem"]
duration: "25 min"
publishedAt: "2023-01-15T00:00:00"
hiddenFromMainPage: true
---
import { Lecture } from "~/components";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faFacebookSquare, faGithub, faLinkedin, faSkype } from "@fortawesome/free-brands-svg-icons";
import { ivanHedz2023Avatar } from "../../../../assets/images/avatars/intro-rounded";
import aEtoMagazin from "../assets/images/a-eto-magazin.png";
import exceptionClassHierarchy from "../assets/images/exception-class-hierarchy.jpg";
import boxingUnboxing from "../assets/images/boxing-unboxing.gif";
import constraintsTypes from "../assets/images/constraints-types.png";
import nugetLogo from "../assets/images/nuget-logo.png";
import dotnetPlatform from "../assets/images/dotnet-platform.jpg";
import dotnet6Platform from "../assets/images/net-6-ecosystem.png";
import lambdaExpressionStructure from "../assets/images/lambda-expression-structure.png";
import delegateEventFlow from "../assets/images/delegate-event-flow.png";
import collectionsHierarchy from "../assets/images/collections-hierarchy.jpg";
import stack from "../assets/images/stack.jpg";
import stackAndHeap from "../assets/images/stack-and-heap.gif";
import SnippetL02S01 from "../assets/snippets/snippet-l02-s01.mdx";
import SnippetL02S02 from "../assets/snippets/snippet-l02-s02.mdx";
import SnippetL02S03 from "../assets/snippets/snippet-l02-s03.mdx";
import SnippetL02S04 from "../assets/snippets/snippet-l02-s04.mdx";
import SnippetL02S05 from "../assets/snippets/snippet-l02-s05.mdx";
import SnippetL02S06 from "../assets/snippets/snippet-l02-s06.mdx";
import SnippetL02S07 from "../assets/snippets/snippet-l02-s07.mdx";
import SnippetL03S01 from "../assets/snippets/snippet-l03-s01.mdx";
import SnippetL03S02 from "../assets/snippets/snippet-l03-s02.mdx";
import SnippetL03S03 from "../assets/snippets/snippet-l03-s03.mdx";
import SnippetL03S04 from "../assets/snippets/snippet-l03-s04.mdx";
import SnippetL03S05 from "../assets/snippets/snippet-l03-s05.mdx";
import SnippetL03S06 from "../assets/snippets/snippet-l03-s06.mdx";
import SnippetL03S07 from "../assets/snippets/snippet-l03-s07.mdx";
import SnippetL03S08 from "../assets/snippets/snippet-l03-s08.mdx";
import SnippetL03S09 from "../assets/snippets/snippet-l03-s09.mdx";
import SnippetL03S10 from "../assets/snippets/snippet-l03-s10.mdx";
import SnippetL03S11 from "../assets/snippets/snippet-l03-s11.mdx";
import SnippetL03S12 from "../assets/snippets/snippet-l03-s12.mdx";
import SnippetL03S13 from "../assets/snippets/snippet-l03-s13.mdx";
import SnippetL03S14 from "../assets/snippets/snippet-l03-s14.mdx";
import SnippetL03S15 from "../assets/snippets/snippet-l03-s15.mdx";
import SnippetL03S16 from "../assets/snippets/snippet-l03-s16.mdx";
import SnippetL03S17 from "../assets/snippets/snippet-l03-s17.mdx";
import SnippetL03S18 from "../assets/snippets/snippet-l03-s18.mdx";
import SnippetL03S19 from "../assets/snippets/snippet-l03-s19.mdx";
import SnippetL03S20 from "../assets/snippets/snippet-l03-s20.mdx";
import SnippetL03S21 from "../assets/snippets/snippet-l03-s21.mdx";
import SnippetL03S22 from "../assets/snippets/snippet-l03-s22.mdx";
import SnippetL03S23 from "../assets/snippets/snippet-l03-s23.mdx";
import SnippetL03S24 from "../assets/snippets/snippet-l03-s24.mdx";
import SnippetL03S25 from "../assets/snippets/snippet-l03-s25.mdx";
import SnippetL03S26 from "../assets/snippets/snippet-l03-s26.mdx";
import SnippetL03S27 from "../assets/snippets/snippet-l03-s27.mdx";
import SnippetL03S28 from "../assets/snippets/snippet-l03-s28.mdx";
import SnippetL03S29 from "../assets/snippets/snippet-l03-s29.mdx";
import SnippetL03S30 from "../assets/snippets/snippet-l03-s30.mdx";
import SnippetL03S31 from "../assets/snippets/snippet-l03-s31.mdx";
import SnippetL03S32 from "../assets/snippets/snippet-l03-s32.mdx";
import SnippetL03S33 from "../assets/snippets/snippet-l03-s33.mdx";
import SnippetL03S34 from "../assets/snippets/snippet-l03-s34.mdx";
import SnippetL04S01 from "../assets/snippets/snippet-l04-s01.mdx";
import SnippetL04S02 from "../assets/snippets/snippet-l04-s02.mdx";
import SnippetL04S03 from "../assets/snippets/snippet-l04-s03.mdx";
import SnippetL04S04 from "../assets/snippets/snippet-l04-s04.mdx";
import SnippetL04S05 from "../assets/snippets/snippet-l04-s05.mdx";
import SnippetL04S06 from "../assets/snippets/snippet-l04-s06.mdx";
import SnippetL04S07 from "../assets/snippets/snippet-l04-s07.mdx";
import SnippetL04S08 from "../assets/snippets/snippet-l04-s08.mdx";
import SnippetL04S09 from "../assets/snippets/snippet-l04-s09.mdx";
import SnippetL04S10 from "../assets/snippets/snippet-l04-s10.mdx";
import SnippetL04S11 from "../assets/snippets/snippet-l04-s11.mdx";
import SnippetL04S12 from "../assets/snippets/snippet-l04-s12.mdx";
import "../styles.css";

<div><h1><strong>.NET ecosystem and C# best practices</strong></h1></div>

<Language
  currentLanguage="en"
  languages={{"en": "lectures/dotnet-ecosystem-and-csharp-best-practices/en", "ua": "lectures/dotnet-ecosystem-and-csharp-best-practices/"}
}/>

<VideoWrapper duration="35 min">
  <iframe src="https://www.youtube.com/embed/qESDPe_Gj5Y" frameBorder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowFullScreen></iframe>
</VideoWrapper>

<div>
  <div class="author">
    <div class="avatar-wrapper">
      <object class="avatar-object" data={ivanHedz2023Avatar} role="img" aria-label="My profile picture"></object>
    </div>
    <div class="profile">
      <h3 class="name">Ivan Hedz</h3>
      <p class="about">Ivan workes as Full Stack Web Developer in <a href="https://binary-studio.com"><strong>Binary Studio</strong></a>. Tech stack is C# and Typescript. Hobbies ‚Äì listening to music, arcade games and yoga. Decided to record a lecture for the Academy for the first time so that it would be easier for you to understand the .NET ecosystem.</p>
    </div>
  </div>
  <div class="bubble" style={{ margin: "-0.5em 1em 1em"}}>
    <strong class="dorov">Hello!</strong>
    <br />
    The lecture about the .NET ecosystem and best practices for writing C# code will start in 5..4..3... But first, ü•Å some disclaimers about the lecture itself.
    <ol class="compact inverted">
      <li>You have probably already heard (or not) about much of what will be discussed;</li>
      <li>Some topics are talked about superficially, without going into details;</li>
      <li>The lecture may seem long, but believe me is faster than diving into the MSDN documentation in search of the necessary information.</li>
    </ol>
    <p>You will also need a .NET developer starter pack: <a href="https://dotnet.microsoft.com/download" title=".NET"><strong>.NET</strong></a>, <a href="https://git-scm.com/" title="Git"><strong>Git</strong></a>, <a href="https://visualstudio.microsoft.com/" title="Visual Studio"><strong>Visual Studio</strong></a> or <a href="https://www.jetbrains.com/rider/" title="Rider"><strong>Rider</strong></a>.</p>
  </div>
</div>
<div id="table-of-contents" className="table-of-contents" style={{ marginTop: 1 + "em"}}>
    <TimelineOfContents timeline={[{
      linkTo: "#dotnet-platform-overview",
      title: "Review .NET platform"
    }, {
      linkTo: "#dotnet-under-the-hood",
      title: ".NET under the hood"
    }, {
      linkTo: "#csharp-essential-topics",
      title: "The most important concepts C#"
    }, {
      linkTo: "#clean-code-principles",
      title: "The principles of pure code"
    }]} />
</div>

<Level id="dotnet-platform-overview" number="1" name="Overview of the .NET Platform" difficulty={<span><a href="https://www.urbandictionary.com/define.php?term =easy%20peasy%20lemon%20squeezy">Easy peasy lemon squeezy</a>.</span>} objectives={<span>Read/hear about the .NET platform in general <em>(Won't take long)</em>.</span>} labels={{ level: "Section", backToTop: "Top", difficulty: "Difficulty:", objectives: "Objective:" }} />
<p style={{ marginLeft: 0.25 + "em"}}> Microsoft is on top right now, have you heard about OpenAI company and their products like ChatGPT or DALL-E-2? Well it's 49% Microsoft üòé.
    .Net ecosystem is also supported by that company, just imagine what would be the best ecosystem in the future.</p>
<ul>
  <li className="details">
    <input type="checkbox" id="accordion-1-1" />
    <label className="summary" htmlFor="accordion-1-1">
      <h5>
        <strong>.NET</strong> Platform right now
      </h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.5 + "em"}}>
      <img src={dotnetPlatform} alt="dotnet-platform" />
      <div className="columns text-center" style={{ display: "none"}}>
        <div className="column col-4">
          <div className="panel">
            <div className="panel-header">
              <strong>.NET Framework</strong>
            </div>
            <div className="panel-body">
              <div className="columns">
                <div className="column col-2">WPF</div>
                <div className="column col-7">Windows Forms</div>
                <div className="column col-3">ASP.NET</div>
              </div>
            </div>
          </div>
        </div>
        <div className="column col-4">
          <div className="panel">
            <div className="panel-header">
              <strong>.NET Core</strong>
            </div>
            <div className="panel-body">
              <div className="columns">
                <div className="column col-6">UWP</div>
                <div className="column col-6">ASP.NET Core</div>
              </div>
            </div>
          </div>
        </div>
        <div className="column col-4">
          <div className="panel">
            <div className="panel-header">
              <strong>Xamarin</strong>
            </div>
            <div className="panel-body">
              <div className="columns">
                <div className="column col-6">iOS</div>
                <div className="column col-6">Android</div>
              </div>
            </div>
          </div>
        </div>
        <div className="column col-12">
          <div className="panel">
            <div className="panel-header">
              <strong>.NET Standard Library</strong>
            </div>
          </div>
        </div>
        <div className="column col-12">
          <div className="panel">
            <div className="panel-header">
              <strong>Common infrastructure</strong>
            </div>
            <div className="panel-body">
              <div className="columns">
                <div className="column col-4">Compilers</div>
                <div className="column col-4">Languages</div>
                <div className="column col-4">Runtime components</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <p>Ways to create .NET applications:</p>
      <ol>
        <li><strong>.NET Framework</strong> - development of Windows desktop applications on <strong>Windows Forms</strong>, <strong>WPF</strong>, web servers on <strong>ASP.NET</strong> and <strong>WCF</strong></li>
        <li><strong>.NET Core</strong> - Develop cross-platform web apps with <strong>ASP.NET Core</strong>, build hybrid apps with <strong>Universal Windows Platform</strong> which allows you to run a program written on this technology on a Windows machine, Xbox, Hololens</li>
        <li><strong>Xamarin</strong> is a platform for building mobile apps for <strong>iOS</strong> and <strong>Android</strong> using C#, XML and XAML</li>
      </ol>
      <p>Code written for a specific framework such as WPF, ASP.NET Core, or Android cannot be reused on another platform because it is tailored to work with the so-called <em>platform-specific API</em>, which is different everyone has. So that you can reuse the code of business logic, helper methods, models, classes, etc. <strong>.NET Standard</strong> was created. It provides a set of available APIs that work in the same way in all desktop programs, web servers, mobile applications, games and cloud services, regardless of the operating system and platform.</p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-1-2" />
    <label className="summary" htmlFor="accordion-1-2">
      <h5>
        <strong>.NET 6 platform</strong>
      </h5>
    </label>
    <div className="details-body details-body-with-image" style={{ marginBottom: 0.25 + "em"}}>
      <img src={dotnet6Platform} alt="dotnet5-platform" className="top-image" />
      <p>Since November 2021, <strong>.NET 6</strong> was released. Which became a serious improvement of the development system as a whole.
        The main innovation was the provision of support for <strong>Linux</strong>, <strong>macOS</strong>, <strong>iOS</strong>, <strong>Android</strong>, <strong>tvOS</strong>, <strong>watchOS</strong> and <strong>WebAssembly</strong>.
        As a result, it became possible to create applications for different platforms on a common code base with the same build process, regardless of the type of application. So now you can develop with the help of <strong>Visual Studio</strong>, <strong>Visual Studio for Mac</strong>, <strong>Visual Studio Code</strong> - or on any other IDE with help of <strong>dotnet CLI</strong></p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-1-3" />
    <label className="summary" htmlFor="accordion-1-3">
      <h5><strong>NuGet</strong></h5>
    </label>
    <div className="details-body details-body-with-image" style={{ marginBottom: 0.25 + "em"}}>
      <img src={nugetLogo} alt="nuget-logo" className="top-image" />
      <p>Each programmer sooner or later has to implement functionality that someone has already created or even published in part or in full (usually in the form of an <i>DLL library</i>). Developers refer to such modules as "packages", which contain compiled code, additional asset files, and a manifest that explains the purpose and use of the package. Most programming languages have their own platforms for sharing such useful modules. In .NET, this is the <strong>NuGet</strong> supported by Microsoft. Developers who have created a cool tool or, for example, a library for working with the file system, can publish their work as a <strong>NuGet package</strong> in the form of an <em>zip file</em> with a <strong> extension. nupkg</strong>. You can search and download modules that will speed up the development of your application from the central <strong>NuGet Gallery</strong> repository - it already has about 250,000 unique packages and you might find something useful there.</p>
    </div>
  </li>
</ul>
<Level id="dotnet-under-the-hood" number="2" name=".NET under the hood" difficulty={<span style={{ color: "orangered", fontWeight: "bold" }}>Hard as hell üî•</span>} objectives="Understand the SDK." labels={{ level: "Section", backToTop: "Top", difficulty: "Difficulty:", objectives: "Objective:" }} />
<ul>
  <li className="details">
    <input type="checkbox" id="accordion-2-1" />
    <label className="summary" htmlFor="accordion-2-1">
      <h5 style={{ display: 'flex', alignItems: 'center'}}>
        <span style={{ marginRight: 0.25 + "rem"}}><strong>CLR</strong></span>
        <small style={{ fontSize: 0.5 + "em", textTransform: 'uppercase'}}>
          Common Language Runtime
        </small>
      </h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>The most common programming languages in the .NET world today are <strong>C#</strong>, <strong>F#</strong>, and <strong>Visual Basic</strong>.
        Each has its own compiler that converts code written in that language into <strong>Intermediate Language Code (IL)</strong>. The latter is a set of instructions for the .NET virtual machine - <strong>CLR (Common Language Runtime)</strong>.</p>
      <p>Basic steps in running a .NET program:</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-2-1-1" />
          <label className="summary" htmlFor="accordion-2-1-1">
            First, the compiler will turn the written code from C# into IL:
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <div className="columns">
              <div className="column col-6">
                Plain C# code
                <div>
                  <SnippetL02S01 />
                </div>
              </div>
              <div className="column col-6">
                C# code compiled to IL
                <div>
                  <SnippetL02S02 />
                </div>
              </div>
            </div>
          </div>
        </li>
        <li>And when it comes time to execute a piece of code in a program, the CLR will use the <strong>JIT (Just in Time)</strong> compiler to turn the IL code into machine code.</li>
      </ul>
      <p>The result of building a .NET program is a file with the extension <strong>.exe</strong> (Executable) or <strong>.dll</strong> (Dynamic Link Library).</p>
      <div className="bubble small subtle">
        <p>It is important to note that when converting IL to native code, only the part of the code that should be executed at the current time will be converted.</p>
      </div>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-2-2" />
    <label className="summary" htmlFor="accordion-2-2">
      <h5><strong>Value</strong> and <strong>Reference</strong> types</h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>At the highest level, there are 2 data types in C# - <strong>value types</strong> and <strong>reference types</strong>. It is important to understand the differences between them:</p>
      <div className="columns">
        <div className="column col-6">
          Significant types:
          <ul>
            <li>Integer types</li>
            <li>Floating point types</li>
            <li>decimal</li>
            <li>bool</li>
            <li>enums</li>
            <li>structs</li>
          </ul>
        </div>
        <div className="column col-6">
          Reference types:
          <ul>
            <li>type object</li>
            <li>string</li>
            <li>classes</li>
            <li>interfaces</li>
            <li>delegates</li>
          </ul>
        </div>
      </div>
      <p>Value types are stored on the stack, reference types are stored on the heap. <strong>Value types</strong> are passed by value, i.e. copied, <strong>reference types</strong> are passed by reference.</p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-2-3" />
    <label className="summary" htmlFor="accordion-2-3">
      <h5><strong>Stack</strong> and <strong>Heap</strong></h5>
    </label>
    <div className="details-body details-body-with-image" style={{ marginBottom: 0.25 + "em"}}>
      <img src={stackAndHeap} alt="stack-and-heap" className="top-image" />
      <p>In <strong>.NET</strong>, memory is divided into two types: <strong>stack</strong> and <strong>heap</strong>.
        <strong> Stack</strong> is a data structure that grows from bottom to top: each new element is placed on top of the previous one.
        The stack stores <em>value types</em> and <em>refs to reference types</em>, which in turn are stored on the heap.</p>
      <p><strong>A heap</strong> can be thought of as an unordered collection of heterogeneous objects.
        When an object of <em>reference type</em> is created, a reference to the address of this object in the <strong>heap</strong> is added to the stack.
        When an <em>reference type object</em> is no longer used, the reference is removed from the stack and the memory is freed.</p>
      <p>In .NET, memory cleanup happens automatically. The <strong>Garbage Collector</strong> is responsible for this (in our opinion, the garbage collector). When it sees that an object on the heap is no longer referenced, it removes that object and cleans up memory.</p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-2-4" />
    <label className="summary" htmlFor="accordion-2-4">
      <h5><strong><code>ref</code></strong> and <strong><code>out</code></strong> parameters</h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>An important point is how the <em>value</em> and <em>reference type</em> variables are passed to the method.</p>
      <div className="columns">
        <div className="column col-6">
          <h3>Value Type</h3>
          <div>
            <SnippetL02S03 />
          </div>
        </div>
        <div className="column col-6">
          <h3>Reference Type</h3>
          <div>
            <SnippetL02S06 />
          </div>
        </div>
        <div className="column col-6">
          <h3>ref</h3>
          <div>
            <SnippetL02S04 />
          </div>
        </div>
        <div className="column col-6">
          <h3>Out</h3>
          <div>
            <SnippetL02S05 />
          </div>
        </div>
      </div>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-2-5" />
    <label className="summary" htmlFor="accordion-2-5">
      <h5><strong>Boxing</strong> / <strong>Unboxing</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>The boxing operation - <strong>boxing</strong> - is allocating memory on the heap for an object of a value type - value type, and assigning a reference to this memory area to a variable on the stack. Unboxing - <strong>unboxing</strong>, on the contrary, allocates memory on the stack for an object obtained from the heap by reference.</p>
      <div className="parallel blocks">
        <SnippetL02S07 />
        <img src={boxingUnboxing} alt="boxing-unboxing" />
      </div>
    </div>
  </li>
</ul>
<Level id="csharp-essential-topics" number="3" name="Most Important C# Topics" difficulty="Not bad." objectives="Understand the SDK." labels={{ level: "Section", backToTop: "top", difficulty: "Difficulty:", objectives: "Objective:" }} />
<ul>
  <li className="details">
    <input type="checkbox" id="accordion-3-1" />
    <label className="summary" htmlFor="accordion-3-1">
      <h5><strong>Class vs Struct</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><strong>Structures</strong> are very similar in appearance to <strong>Classes</strong>, but there is a fundamental difference that was mentioned earlier. <span style={{ textDecoration: "underline" }}>Class</span> is <strong>reference type</strong> and is passed by reference, while <span sstyle={{ textDecoration: "underline" }}>structure</span> is <strong>value type</strong> and is passed by value ‚Äî that is, copied.</p>
      <p><em>Structures</em> are best used for small classes, small data structures, and lightweight objects. <em>Classes</em> can be used in all cases where it is inconvenient for you to use a structure. They are great for being part of an entity hierarchy, having internal state, and containing a lot of business logic.</p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-2" />
    <label className="summary" htmlFor="accordion-3-2">
      <h5><strong>Static members</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>Classes and structures can have <em>static fields</em>, <em>methods</em> and <em>properties</em>. If a member is static, then it refers to the entire class or structure and does not need to be instantiated to refer to.</p>
      <SnippetL03S01 />
      <p>The example shows that <em>static field</em> is common to all objects of the class and can be used in <em>non-static methods</em>. At the same time, in <em>static methods</em> we do not have access to <em>non-static members</em> of the class.</p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-3" />
    <label className="summary" htmlFor="accordion-3-3">
      <h5><strong>Params</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>Using the keyword <code>params</code> we can "say" that our method takes an indefinite number of parameters - it can be zero or more, any number.</p>
      <SnippetL03S02 />
      <p>When a method has a variable number of parameters, we pass arguments to it simply by listing them separated by commas, as shown in the example. It is worth noting that the <code>params</code> argument must be specified last, after the list of all strictly defined method arguments.</p>
    </div>
  </li>
    <li className="details">
    <input type="checkbox" id="accordion-3-5" />
    <label className="summary" htmlFor="accordion-3-5">
      <h5><strong>Interface vs Abstract Class</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>In C#, <em>abstraction</em> is used to hide implementation details.
        This means that we are focusing on what an object can do rather than how it does it. This is often used when writing large and complex programs.
        The main tools for this are <em>abstract classes</em> and <em>interfaces</em>.</p>
      <p>In an <em>abstract class</em>, we can <strong>create functionality that is implemented in a class inherited from it.</strong>.
        For its part, an <em>interface</em> allows <strong>to define functionality or functions, but cannot implement them.</strong>.</p>
      <p>A class implements an interface and must implement these methods.
        Let's look at a few key differences between them:</p>
      <ol>
        <li>
          An <em>interface</em> cannot have member access modifiers - everything in an <em>interface</em> is public by default. For an abstract class, everything remains the same as for a regular class.
          <div className="columns">
            <div className="column col-6">
              <SnippetL03S03 />
            </div>
            <div className="column col-6">
              <SnippetL03S04 />
            </div>
          </div>
        </li>
        <li>
          In an <em>interface</em>, we can only describe the signature of a method without implementing it. And in the <em>abstract class</em> there can be both abstract methods and properties, and non-abstract ones - with full or partial implementation.
          <div className="columns">
            <div className="column col-6">
              <SnippetL03S05 />
            </div>
            <div className="column col-6">
              <SnippetL03S06 />
            </div>
          </div>
        </li>
        <li>
          We cannot declare a constructor in the body of an <em>interface</em> with or without an access modifier. In an <em>abstract class</em>, we can declare constructors in the same way as in regular classes. It is mainly used to call in the <em>derived class</em> constructor so as not to duplicate the field or property initialization code of the <em>abstract class</em>.
          <div className="columns">
            <div className="column col-6">
              <SnippetL03S07 />
            </div>
            <div className="column col-6">
              <SnippetL03S08 />
            </div>
          </div>
        </li>
        <li>
          We cannot explicitly instantiate an <em>interface</em> or <em>abstract class</em> by calling the constructor. Although let me remind you that <em>abstract class</em> can have it.
          <SnippetL03S09 />
        </li>
        <li>
          An <em>abstract class</em> can have fields and properties, an <em>interface</em> can only have properties.
          <div className="columns">
            <div className="column col-6">
              <SnippetL03S10 />
            </div>
            <div className="column col-6">
              <SnippetL03S11 />
            </div>
          </div>
        </li>
      </ol>
      <h6>What, why and where?</h6>
      <p>The <strong>Interface</strong> we use to describe the <strong>API</strong> for multiple classes that are likely to implement more than one interface. Remember that interface members cannot be static. <em>C#</em>, unlike <em>C++</em>, does not support multiple inheritance, so we use interfaces to implement it.</p>
      <p><strong>Abstract class</strong> is used if we want to include it in the inheritance hierarchy and create functionality with a full or partial implementation that the derived class can implement or override. <em>Abstract class</em> allows you to save the state of the class as a whole, and not just its individual object.</p>
      <p><em>Interface</em> is mainly used when we just want to describe the <strong>API</strong> usage of the classes that will implement this interface - set the behavior.</p>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-IDisposable" />
    <label className="summary" htmlFor="accordion-3-IDisposable">
      <h5><strong>IDisposable interface</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><code>IDisposable</code> declares a single <code>Dispose</code> method, in which the implementation of the interface in the class should release unmanaged resources such as database connections, file descriptors, network connections, and volumes. similar.
        Unmanaged resources should be freed as soon as possible, before the object is removed from memory when the <em>Garbage Collector</em> gets to it.
        For example, our class interacts with the file system - opens a file, reads something from it, writes. And it's better to finish working with this file as soon as possible so that other programs or threads can use it.
        And another thing, we ourselves need to explicitly call the <code>Dispose</code> method, because the <em>Garbage Collector</em> knows nothing about it. This is best done in a <code>try...finally</code> block so that even if an error occurs, we can free the resources and clean up the memory properly.</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-IDisposable-example" />
          <label className="summary" htmlFor="accordion-3-IDisposable-example">
            IDisposable implementation example
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S31 />
          </div>
        </li>
      </ul>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-7" />
    <label className="summary" htmlFor="accordion-3-7">
      <h5><strong>Extension methods</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><em>Extension methods</em> allow you to "add" methods to existing types without creating a new derived type, recompiling, or modifying the original type.
        The <em>Extension method</em> is a special <em>static method</em> that must be a member of a static class.</p>
      <SnippetL03S14 />
      <p>The example shows the <em>Extension method</em> for the <code>String</code> type. The <em>Static class</em> can have an arbitrary name, while the name of the method must be different from the existing methods in the class we are extending, or have a different signature.
        In the future, we can use the method we declared in the same way as ordinary methods of the class we are extending.</p>
    </div>
  </li>
    <li className="details">
    <input type="checkbox" id="accordion-3-8" />
    <label className="summary" htmlFor="accordion-3-8">
      <h5><strong>Generics</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><strong>Generics</strong> appeared in <strong>C# 2.0</strong>. They brought the concept of <em>typed parameters</em> to <strong>.NET</strong> - this allows you to design classes and methods that determine the type of class or method members only at initialization.</p>
      <p>For example, using a generic type parameter <code>T</code>, we can write a single class that will be used by client code without the risk of performing <em>boxing</em> operations (which are heavy operations in their own right). , and abuse them is not good).</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-Generic-example" />
          <label className="summary" htmlFor="accordion-3-Generic-example">
            An example of declaring a <code>Generic</code> class
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S15 />
            <p>As you can see from the code above, <code>MyGenericClass</code> is defined with <code>&lt;T&gt;</code>. <code>&lt;T&gt;</code> indicates that <code>MyGenericClass</code> is a generic, and the <code>T</code> type will be defined later. You can use any letter or word instead of <code>T</code>, it doesn't matter.</p>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Generic-example-2" />
          <label className="summary" htmlFor="accordion-3-Generic-example-2">
            An example of creating an instance of the <code>Generic</code> class
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S16 />
            <p>The compiler now infers the type of class members based on the type passed in by the programmer when the class was created. For example, the following code uses the data type <code>int</code>.</p>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Generic-constraints" />
          <label className="summary" htmlFor="accordion-3-Generic-constraints">
            Restrictions in <code>Generic</code>
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p>C# has <em>Constraint</em>s to restrict the types that can be used in a generic class. For example, if through <em>Constraint</em> we indicate that the type <code>T</code> can only be <em>reference type</em>, that is, classes, then we will not be able to use <em>value type</em> to instantiate the generic class.
              Accordingly, after that we cannot use structural types such as <code>int</code> - this will cause a compilation error.</p>
            <SnippetL03S17 />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Generic-all-constraints" />
          <label className="summary" htmlFor="accordion-3-Generic-all-constraints">
            All <code>Generic</code> restrictions
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p>Here are all possible <em>Constraint</em>-s that can be used to constrain types for use in generic classes:</p>
            <img src={constraintsTypes} alt="constraints-types" />
          </div>
        </li>
      </ul>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-4" />
    <label className="summary" htmlFor="accordion-3-4">
      <h5><strong>Nullable</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>Obviously <em>structural data type</em> we cannot assign <code>null</code> values. To do this, we need to declare a variable with the <code>?</code> modifier. This modifier is an <em>alias</em> of the <code>Nullable&lt;T&gt;</code></p> structure
      <SnippetL03S18 />
      <p>Signature <code>Nullable&lt;T&gt;</code>:</p>
      <SnippetL03S19 />
      <p>When we wrap a variable in a <code>Nullable</code> type, we have a new <strong>API</strong> to interact with this variable:</p>
      <ul>
        <li>Property <code>HasValue</code>, returns <code>true</code> if the variable has a value and <code>false</code> if it is <code>null</code> </li>
        <SnippetL03S20 />
        <li><code>Value</code> returns the actual value stored in the variable if <code>HasValue</code> is equal to <code>true</code>. Otherwise, <code>Value</code> throws <code>InvalidOperationException</code> if the variable is <code>null</code>.</li>
      </ul>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-10" />
    <label className="summary" htmlFor="accordion-3-10">
      <h5><strong>Events & Delegates + Lambdas</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><strong>Delegates</strong> are objects that point to methods; with them we can call the methods assigned to the delegate. Delegates allow you to represent methods as objects and pass them to functions, use them as <em>callbacks</em>.</p>
      <p><strong>Events</strong> are delegate objects that report that some event (<em>action</em>) has occurred.</p>
      <p><strong>Lambda expressions</strong> are shorthand for <em>anonymous methods</em>. This allows you to create concise methods that can return some value.</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-Lambdas" />
          <label className="summary" htmlFor="accordion-3-Lambdas">
            Syntax of lambda expressions
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <img src={lambdaExpressionStructure} alt="lambdaExpressionStructure" />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Delegates" />
          <label className="summary" htmlFor="accordion-3-Delegates">Delegate example</label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S21 />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Action" />
          <label className="summary" htmlFor="accordion-3-Action"><code>Action</code>, <code>Func</code> and <code>Predicate</code></label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p>Instead of defining a new delegate type, you can use the already defined <em>Action</em>, <em>Func</em>, and <em>Predicate</em> delegates.</p>
            <ul>
              <li>
                The generic delegate <em>Action &lt;T&gt;</em> is intended to refer to a method that returns <code>void</code>. You can pass up to 16 parameters of any type to this delegate class.
                <SnippetL03S22 />
              </li>
              <li>
                The <em>Func</em> delegates can be used in a similar way. Func allows you to call methods that return something. It can also be passed up to 16 types of parameters and 1 type that it returns.
                <SnippetL03S23 />
              </li>
              <li>
                The <em>Predicate</em> delegate is used to compare whether some <em>T</em> object meets a certain condition. It returns <code>true</code> if the object satisfies the condition, and <code>false</code> if it doesn't.
                <SnippetL03S24 />
              </li>
            </ul>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-events" />
          <label className="summary" htmlFor="accordion-3-Events">Events & Delegates Flow</label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <img src={delegateEventFlow} alt="delegateEventFlow" />
            <p><strong>Events</strong> allow you to tell the system that a specific action has taken place.</p>
            <p>There is this model: <strong>Publisher-Subscriber</strong><em>(Publisher-Subscriber)</em>. The <em>Subscriber</em> subscribes to the event, defines a handler, and waits for the <em>Publisher</em> to execute the event before triggering it.</p>
          </div>
        </li>
      </ul>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-10" />
    <label className="summary" htmlFor="accordion-3-10">
      <h5><strong>Events & Delegates + Lambdas</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><strong>Delegates</strong> are objects that point to methods; with them we can call the methods assigned to the delegate. Delegates allow you to represent methods as objects and pass them to functions, use them as <em>callbacks</em>.</p>
      <p><strong>Events</strong> are delegate objects that report that some event (<em>action</em>) has occurred.</p>
      <p><strong>Lambda expressions</strong> are shorthand for <em>anonymous methods</em>. This allows you to create concise methods that can return some value.</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-Lambdas" />
          <label className="summary" htmlFor="accordion-3-Lambdas">
            Syntax of lambda expressions
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <img src={lambdaExpressionStructure} alt="lambdaExpressionStructure" />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Delegates" />
          <label className="summary" htmlFor="accordion-3-Delegates">
            Delegate example
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S21 />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Action" />
          <label className="summary" htmlFor="accordion-3-Action">
            <code>Action</code>, <code>Func</code> and <code>Predicate</code>
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p>Instead of defining a new delegate type, you can use the already defined <em>Action</em>, <em>Func</em>, and <em>Predicate</em> delegates.</p>
            <ul>
              <li>
                The generic delegate <em>Action &lt;T&gt;</em> is intended to refer to a method that returns <code>void</code>. You can pass up to 16 parameters of any type to this delegate class.
                <SnippetL03S22 />
              </li>
              <li>
                The <em>Func</em> delegates can be used in a similar way. Func allows you to call methods that return something. It can also be passed up to 16 types of parameters and 1 type that it returns.
                <SnippetL03S23 />
              </li>
              <li>
                The <em>Predicate</em> delegate is used to compare whether some <em>T</em> object meets a certain condition. It returns <code>true</code> if the object satisfies the condition, and <code>false</code> if it doesn't.
                <SnippetL03S24 />
              </li>
            </ul>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-events" />
          <label className="summary" htmlFor="accordion-3-Events">
            Events & Delegates Flow
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <img src={delegateEventFlow} alt="delegateEventFlow" />
            <p><strong>Events</strong> allow you to tell the system that a specific action has taken place.</p>
            <p>There is this model: <strong>Publisher-Subscriber</strong><em>(Publisher-Subscriber)</em>. The <em>Subscriber</em> subscribes to the event, defines a handler, and waits for the <em>Publisher</em> to execute the event before triggering it.</p>
          </div>
        </li>
      </ul>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-11" />
    <label className="summary" htmlFor="accordion-3-11">
      <h5><strong>Collections</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>In C#, there are <em>arrays</em> that store <em>sets of similar objects</em>, but working with them is not always convenient. Since an array stores <em>a fixed number of objects</em>, in cases where we do not know in advance how many we will have, it will be much more convenient to use <em>collections</em>.</p>
      <p>When choosing collections, it can be decisive that some of them implement standard data structures, such as:</p>
      <ul>
        <li>stack</li>
        <li>queue</li>
        <li>dictionary</li>
        <li>hash table</li>
      </ul>
      <p>...which can be useful for various special tasks. The basis for creating all collections is the implementation of the interfaces <code>IEnumerator</code> and <code>IEnumerable</code>.</p>
      <p>The <code>IEnumerator</code> interface represents an <em>enumerator</em> that makes it possible to iterate through a collection, for example in a <code>foreach</code> loop, or by means of <a href="https: //docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">LINQ</a>. And the <code>IEnumerable</code> interface, through its <code>GetEnumerator</code> method, provides an enumerator to all classes that implement this interface. Therefore, the <code>IEnumerable</code> interface is the base interface for all collections.</p>
      <p>Specific methods and uses may differ from one collection class to another, but the general principles will be the same for all collection classes.</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-Collections-Hierarchy" />
          <label className="summary" htmlFor="accordion-3-Collections-Hierarchy">
            Collections Hierarchy
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <img src={collectionsHierarchy} alt="collectionsHierarchy" />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-ArrayList" />
          <label className="summary" htmlFor="accordion-3-ArrayList">
            ArrayList & List
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p>This example uses two collections: <strong>non-generic</strong> is <code>ArrayList</code> and <strong>generic</strong> is <code>List</code>. It is now considered good practice to use the generic version of collections wherever possible due to strong typing and ease of use. Most collections support adding items.</p>
            <SnippetL03S25 />
            <p>For example, in this case, adding is done using the <code>Add</code> method, but for other collections, the name of the method may differ. Also, most collections implement removal (in this example, it is done using the <code>RemoveAt</code> method, which removes an element from the collection by index). Using the <code>Count</code> property, you can see the number of elements in the collection.</p>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Stack" />
          <label className="summary" htmlFor="accordion-3-Stack">
            Stack
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p><code>Stack&lt;T&gt;</code> represents a collection that uses the <strong>LIFO</strong> - last in - first out - algorithm. With this data organization, each next element is placed on top of the previous one. Elements are retrieved from the collection in the reverse order - the element that is highest on the stack is retrieved.</p>
            <img src={stack} alt="stack" />
            <p>In the <code>Stack</code> class, there are two main methods that allow you to manage elements - these are:</p>
            <ul>
              <li><code>Push</code>: Pushes an element onto the stack in first place</li>
              <li><code>Pop</code>: Gets the first element from the stack</li>
              <li><code>Peek</code>:* simply returns the first element from the stack without removing it</li>
            </ul>
            <SnippetL03S32 />
            <div className="bubble medium subtle">The example shows how we instantiate the ribbon stack collection. Add 3 cities ‚Äî "Lviv", "Kyiv", "Odessa" using the <code>Push</code> method. We pull out the element that we added last using the <code>Pop</code> method and display the results on the screen.</div>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Dictionary" />
          <label className="summary" htmlFor="accordion-3-Dictionary">
            Dictionary
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p><code>Dictionary</code> <em>(dictionary)</em> stores objects that represent a key-value pair. It is very handy to use to organize the correspondence of something to something.</p>
            <p>Each such object is an instance of the <code>KeyValuePair&lt;TKey, TValue&gt;</code> structure. Thanks to the <code>Key</code> and <code>Value</code> properties that this structure has, we can get the key and value of the element in the dictionary.</p>
            <SnippetL03S26 />
          </div>
        </li>
      </ul>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-3-9" />
    <label className="summary" htmlFor="accordion-3-9">
      <h5><strong>Tuples</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>If you need to glue two values together to return them to a function, or put two values into a <em>hashset</em>, you can use the <code>System.ValueTuple</code></p> types
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-Tuples-1" />
          <label className="summary" htmlFor="accordion-3-Tuples-1">
            An example of using a tuple
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S27 />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Tuples-2" />
          <label className="summary" htmlFor="accordion-3-Tuples-2">
            Different scenarios for using tuples
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S28 />
            <ol>
              <li>Creating a tuple</li>
              <li>Using a tuple to type <code>Dictionary</code></li>
              <li>Adding tuple elements to <code>Dictionary</code></li>
              <li>Returning a dictionary value by key</li>
              <li>Destructuring a tuple element</li>
              <li>Access tuple members by name</li>
            </ol>
          </div>
        </li>
      </ul>
    </div>
  </li>
    <li className="details">
    <input type="checkbox" id="accordion-3-12" />
    <label className="summary" htmlFor="accordion-3-12">
      <h5><strong>Exceptions</strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>Sometimes when running a program, errors occur that are difficult or impossible to predict (for example, when transferring a file over a network, the Internet connection may be interrupted). Such situations are called <strong>Exception</strong>s. The C# language provides developers with the ability to handle such situations using the <code>try...catch...finally</code></p> construct
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-3-try-catch-finally" />
          <label className="summary" htmlFor="accordion-3-try-catch-finally">
            <code>try...catch...finally</code> example
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <SnippetL03S29 />
            <ol>
              <li>When using a <code>try...catch...finally</code> block, all statements in the <code>try</code> block are executed first.</li>
              <li>If no <em>Exception</em>s occurred in this block, then the <code>finally</code> block will be executed after it and the <code>try..catch..finally</code> construction will complete your work.</li>
              <li>If an <em>Exception</em> occurs in a <code>try</code> block, then the normal flow of execution stops and the CLR starts looking for a <code>catch</code> block that can handle this <em>Exception</em>.</li>
              <li>If the <code>catch</code> block is found, then it is executed, and after its completion, the <code>finally</code> block is executed.</li>
              <li>If the required <code>catch</code> block is not found, the program crashes.</li>
            </ol>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Exceptions-Hierarchy" />
          <label className="summary" htmlFor="accordion-3-Exceptions-Hierarchy">
            <code>Exceptions</code> Hierarchy
          </label>
          <div className="details-body details-body-with-image" style={{ marginBottom: 0.25 + "em"}}>
            <p>In C#, all <em>Exception</em> types are inherited from the <code>Exception</code> parent class, which is further divided into two branches <code>SystemException</code> and <code>ApplicationException </code>.</p>
            <p><code>SystemException</code> is the base class for all <em>CLR</em> or code errors such as <code>DivideByZeroException</code> or <code>NullReferenceException</code> and so on.</p>
            <img src={exceptionClassHierarchy} alt="exceptionClassHierarchy" className="bottom-image" />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Application-Exception" />
          <label className="summary" htmlFor="accordion-3-Application-Exception">
            <code>Application Exception</code>
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p><code>ApplicationException</code> is used for application related exceptions. This type of exception is very convenient to use to create your own custom <em>Exception</em>-s. To do this, you just need to inherit from the <code>Exception</code> class and add what you want there. Further in this class, you can define additional fields, properties, methods, etc.</p>
            <SnippetL03S30 />
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-Exception-properties" />
          <label className="summary" htmlFor="accordion-3-Exception-properties">
            <code>Exception</code> properties
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <div className="sl-block is-focused" data-block-type="text">
              <div className="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text">
                <table>
                  <tbody>
                    <tr>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception.data#System_Exception_Data">Data</a></td>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.idictionary">IDictionary</a> containing data in key-value pairs.</td>
                    </tr>
                    <tr>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception.helplink#System_Exception_HelpLink">HelpLink</a></td>
                      <td>May contain a URL (or URN) to a help file that provides comprehensive information about the cause of the error.</td>
                    </tr>
                    <tr>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception.innerexception#System_Exception_InnerException">InnerException</a></td>
                      <td>This property can be used to create and store an error chain when processing <em>Exception</em>-a. You can use it to create a new exception that contains pre-<em>Exception</em>-s.</td>
                    </tr>
                    <tr>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception.message#System_Exception_Message">Message</a></td>
                      <td>Provides detailed information about the reason for the exception.</td>
                    </tr>
                    <tr>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception.source#System_Exception_Source">Source</a></td>
                      <td>Contains the name of the program or object in which the error occurred.</td>
                    </tr>
                    <tr>
                      <td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.exception.stacktrace#System_Exception_StackTrace">StackTrace</a></td>
                      <td>Contains <em>stack trace</em> which can be used to determine where the error occurred. The <em>Stack trace</em> includes the name of the source file and the line number of the program, if available <em>debug information</em>.</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-3-throw" />
          <label className="summary" htmlFor="accordion-3-throw">
            <code>throw</code> it away!
          </label>
          <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
            <p>After the <code>throw</code> statement, there is a <code>Exception</code>-a object, in whose constructor we can pass an error message. Instead of the generic <em>Exception</em> type, we can specify an object of any other type <code>Exception</code>.</p>
            <SnippetL03S33 />
            <p>Similarly, we can throw <code>Exception</code>s anywhere in the program. But there is also another form of using the <code>throw</code> operator, when nothing is specified after this operator.</p>
            <SnippetL03S34 />
            <p>In this form, the throw statement can only be used in a <code>catch</code> block. The difference between them is that <code>throw</code> without anything keeps the original <code>stack trace</code>, while <code>throw ex</code> resets the <code>stack trace</code> code> to the method currently processing <code>Exception</code>.</p>
          </div>
        </li>
      </ul>
    </div>
  </li>
</ul>
<Level id="clean-code-principles" number="4" name="Clean Code Principles" difficulty="Measure twice, cut once." objectives="Understand how to write code that people want to read." labels={{ level: "Section", backToTop: "Top", difficulty: "Difficulty:", objectives: "Objective:" }} />
<ul>
  <li className="details">
    <input type="checkbox" id="accordion-4-1" />
    <label className="summary" htmlFor="accordion-4-1">
      <h5><strong>Coding Standards and <code>Naming Conventions</code></strong></h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>Translated into human language, generally accepted coding standards and agreed upon rules for how to name variables, functions, etc. This is the C# grammar and spelling adopted by most .NET developers so that other <em> developers (you through X time)</em> could easily and quickly understand what is happening in your code and use it without getting confused in all possible ways to name, say, the <em> argument (and such spelling rules exist in absolutely all programming languages, not only in C#)</em>. It makes no sense to talk about each of the rules for a long time, the main thing for you is to familiarize yourself with the <a href="https://www.dofactory.com/reference/csharp-coding-standards">list of most common C# standards</a>. </p>
      <div className="bubble small subtle">
        If you want to be a civilized developer and earn respect among your colleagues, read a few paragraphs with examples of well-formed code and stick to this format when performing tasks small or large.
      </div>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-4-2" />
    <label className="summary" htmlFor="accordion-4-2">
      <h5 style={{ display: 'flex', alignItems: 'center'}}>
        <span style={{ marginRight: 0.25 + "rem"}}>DRY</span>
        <small style={{ fontSize: 0.5 + "em", textTransform: 'uppercase'}}>
          <span style={{ textDecoration: "line-through", opacity: 0.75, marginRight: 0.25 + 'em'}}>Don't Repeat</span>
          <span style={{ textDecoration: "line-through", opacity: 0.75, marginRight: 0.25 + 'em'}}>Don't Repeat</span>
          <span style={{ textDecoration: "line-through", opacity: 0.75, marginRight: 0.25 + 'em'}}>Don't Repeat</span>
          <span style={{ textDecoration: "line-through", opacity: 0.75, marginRight: 0.25 + 'em'}}>Don't Repeat</span>
          Don't Repeat Yourself
        </small>
      </h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p><strong>Don't repeat yourself</strong> when writing code = don't write multiple times something that can be coded once and called referring to a specific module. An example is a web application containing several blocks of the same design, where each has its own <em>(identical to others!)</em> style descriptions. What is the probability that when all these <em> blocks need to be edited in the same way (manually, because we repeat the same set of styles several times)</em>, the developer will miss one or more of them? When this principle is violated and the implementation of a method or even a class is duplicated without a real need, and several hundred thousand lines of code are written (as in any real project), then for refactoring, changing business logic, or even simple changes in the interface, you have to search for a long time by name method is an unfortunate piece of code, often in order to change only 1 digit in it.</p>
      <div className="bubble small subtle">
        In short, it doesn't work that way. To achieve <strong>DRY</strong> in your code - divide it into small pieces; you see that part of the logic is repeated - take it out right away, combine functions. Why is DRY needed? The less code the better. It's easier to maintain, it takes less time to figure it out, and it also reduces bugs.
      </div>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-4-3" />
    <label className="summary" htmlFor="accordion-4-3">
      <h5 style={{ display: 'flex', alignItems: 'center'}}>
        <span style={{ marginRight: 0 }}><strong>KISS<sup>üíã</sup></strong></span>
        <small style={{ fontSize: 0.5 + "em", textTransform: 'uppercase'}}>
          Keep It Simple Stupid
        </small>
      </h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>This principle speaks for itself - simple and concise code is easier to understand for other developers and for you when you return to it after a while. It is formulated as follows - "each method should solve only one small problem, and not have many different means of consumption." If there are many conditions in the method, then break them into smaller methods. Such code is easier to read, maintain, and it also helps to find bugs much faster. To demonstrate <strong>KISS</strong>, the most common example is to define the day of the week:</p>
      <div className="columns">
        <div className="column col-6">
          <h6><strong>Simple</strong></h6>
          <div>
            <SnippetL04S01 />
          </div>
        </div>
        <div className="column col-6">
          <h6><strong>Stupid</strong></h6>
          <div>
            <SnippetL04S02 />
          </div>
        </div>
      </div>
      <div className="bubble small subtle">
        The slide shows two methods for solving this problem:
        <ol className="compact">
          <li>The first solution is as simple as doors ‚Äî a simple <code>switch</code> with a default <em>case</em> if the day is not found.</li>
          <li>The second method is also working, but in order to understand it, you need to read it longer</li>
        </ol>
        This kind of code exists everywhere, but it's really awkward and looks unprofessional, 99% of programmers would choose to work with something similar to the first option.
      </div>
      <div className="bubble small subtle" style={{ marginTop: 10 }}>
        To achieve <strong>KISS</strong> - try to write as simple code as possible. If you see a complex (unreadable) piece of code, look for a more concise solution to the same problem, and by refactoring what you have written, you will be surprised that a piece of 200 lines is actually not so necessary!
      </div>
    </div>
  </li>
  <li className="details">
    <input type="checkbox" id="accordion-4-4" />
    <label className="summary" htmlFor="accordion-4-4">
      <h5 style={{ display: 'flex', alignItems: 'center'}}>
        <span style={{ fontWeight: 900, marginRight: 0.25 + "em" }}>SOLID</span>
        <small style={{ fontSize: 0.5 + "em", textTransform: 'uppercase'}}>
          Single responsibility, Open‚Äìclosed, Liskov substitution, Interface segregation, Dependency inversion
        </small>
      </h5>
    </label>
    <div className="details-body" style={{ marginBottom: 0.25 + "em"}}>
      <p>SOLID are <strong>5 principles of object-oriented programming</strong> that describe software architecture:</p>
      <p>In simple terms, these are the rules by which you will write easy-to-understand, edit, or reuse code.</p>
      <ul>
        <li className="details">
          <input type="checkbox" id="accordion-4-4-1" />
          <label className="summary" htmlFor="accordion-4-4-1">
            <strong>Single responsibility</strong>
          </label>
          <div className="details-body">
            <p>Single Responsibility Principle. It means that <strong>each class or struct should have only one task.</strong>. All members of the class are written to perform the task given to it, and there is not a single line of code in it that does not apply to the task specified for this block. If we adhere to this principle, then we define classes by their tasks at the design stage of the program.</p>
            <div className="columns">
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="Not SOLID">üò¢</span></h4>
                <div>
                  <SnippetL04S03 />
                </div>
              </div>
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="SOLID">üòé</span></h4>
                <div>
                  <SnippetL04S04 />
                </div>
              </div>
            </div>
            <div className="bubble small subtle">
              I gave the <code>Task</code> class as an example - it saves the task to our database and calculates the time required to solve the task.<br />We conclude that it does not comply with the <strong>Single Responsibility Principle</strong>. Why don't we want it to perform other useful functions, such as determining the time needed to complete a task? Because if after some time the customer's <em> task execution parameters change (for example, due to a release or a change in the composition of the programming team)</em>, we will have to rewrite the <code>Task</code> class in accordance with the changes in the original data, and test whether other functionality that <code>Task</code> performs is broken. According to the <strong>Single Responsibility Principle</strong>, we should create a separate class for calculating the time to complete tasks, which will already be guided by business logic and other incoming data.
            </div>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-4-4-2" />
          <label className="summary" htmlFor="accordion-4-4-2">
            <strong>Open‚Äìclosed</strong>
          </label>
          <div className="details-body">
            <p>Principle of openness / closeness. Our class should be <strong>open for scaling, but closed for modifications</strong>. Our module should be designed in such a way that it is added only when new requirements are created - but related to the initial task. ‚ÄúClosed for modifications‚Äù means that the class is already completely ready and viable, its tasks and purposes do not change, therefore we do not rewrite it significantly, except in case of fixing bugs. In C#, this is achieved by the <strong>principle of inheritance</strong>.</p>
            <div className="columns">
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="Not SOLID">üëé</span></h4>
                <div>
                  <SnippetL04S05 />
                </div>
              </div>
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="SOLID">üëç</span></h4>
                <div>
                  <SnippetL04S06 />
                </div>
              </div>
            </div>
            <div className="bubble small subtle">
              <p>Let's consider an example with a mockup - a page prototype. The problem with this class is that when a customer wants to look at a mockup created by designers, but cannot open an image in <em>tiff</em> or <em>cdr</em> format, the developer will need to introduce a new image format, for example <em>png</em>. Therefore, we will be forced to add a new <code>if</code> condition, which contradicts the <strong>Open Closed Principle</strong>.</p>
              <p>The second example shows how this can be solved - there is a base abstract class <code>Mockup</code> that partially implements image conversion, and child classes implement image conversion to the required format. And if we want to add another format, we just need to create another class that inherits from <code>Mockup</code> and implements the conversion method we need.</p>
            </div>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-4-4-3" />
          <label className="summary" htmlFor="accordion-4-4-3">
            <strong>Liskov substitution</strong>
          </label>
          <div className="details-body">
            <p>According to the principle of Liskov substitution, we must <strong>use any child class instead of the parent</strong> in the same way, without making any changes. A child class cannot violate the type definition given in the parent class and contradict its behavior with its own functionality.</p>
            <div className="columns">
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="Not SOLID">ü§¶‚Äç‚ôÇÔ∏è</span></h4>
                <div>
                  <SnippetL04S07 />
                </div>
              </div>
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="SOLID">üíÅ‚Äç‚ôÇÔ∏è</span></h4>
                <div>
                  <SnippetL04S08 />
                </div>
              </div>
            </div>
            <div className="bubble small subtle">
              Here's how it can be illustrated: <code>Developer</code> is the parent class of <code>JavaScriptDeveloper</code> and <code>CSharpDeveloper</code>. Our <code>Developer</code> class can create backend and frontend applications. It would seem that everything is fine. <code>JavaScriptDeveloper</code> successfully implements 2 methods. But with <code>CSharpDeveloper</code> it's not so simple, he can write a server in <em>ASP.NET</em>, but he can't do it in frontend at all. And if we still try to get a frontend from it, we will catch an error - an exception. In a good way, we need to divide the functionality of <code>Developer</code> into 2 parts: <code>IFrontend</code> and <code>IBackend</code>, and implement them in accordance with the purpose of derived classes: <code> JavaScriptDeveloper</code> implements both <code>IFrontend</code> and <code>IBackend</code>, while <code>CSharpDeveloper</code> only implements <code>IBackend</code>.
            </div>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-4-4-4" />
          <label className="summary" htmlFor="accordion-4-4-4">
            <strong>Interface segregation</strong>
          </label>
          <div className="details-body">
            <p>The principle of separation of interfaces says that you should not pack all the interfaces together in a row, you should <strong>separate them by purpose</strong> so that users can selectively implement only those that use <em>and not all in a row that are available in program</em>.</p>
            <div className="columns">
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="Not SOLID">üí©</span></h4>
                <div>
                  <SnippetL04S09 />
                </div>
              </div>
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="SOLID">üéâ</span></h4>
                <div>
                  <SnippetL04S10 />
                </div>
              </div>
            </div>
            <div className="bubble small subtle">
              <p>Let's assume we have an <code>IDeveloper</code> interface that now knows how to create a server and desktop application. As before, we have <code>JavaScriptDeveloper</code> and <code>CSharpDeveloper</code> that can use this functionality as intended. For <em>JavaScript</em>, the application would be written under Electron, and in C# it would be a WPF application. Everything is great, everyone is happy, but no, because our boss suddenly says that his applications on Electron are lagging and it‚Äôs generally expensive to pay these JavaScript developers. We are cutting back on JavaScript desktop projects, writing only in WPF now. And in this way we break the <strong>Interface Segregation</strong> principle, because our class cannot but perform its functionality, and it turns out that JavaScript developers are still writing desktop projects.</p>
              <p>The solution to this problem will again be to split the interface into several: <code>IDesktop</code> and <code>IBackend</code>. This is similar to the previous example, but here we are solving a different problem - preventing the class from doing more than it needs to.</p>
            </div>
          </div>
        </li>
        <li className="details">
          <input type="checkbox" id="accordion-4-4-5" />
          <label className="summary" htmlFor="accordion-4-4-5">
            <strong>Dependency inversion</strong>
          </label>
          <div className="details-body">
            <p>And now the last and perhaps the most difficult principle to understand is dependency inversion.</p>
            <ol className="inverted">
              <li>High-level classes must not depend on lower-level classes, but both must depend on abstractions.</li>
              <li>Abstractions should not depend on details, but details should depend on abstractions.</li>
            </ol>
            <p>What does this mean? And this means that high-level classes implement business rules or logic in the system. The lower-level classes deal with more detailed operations, such as working with a database, passing messages to the operating system, and so on. To achieve dependency inversion, we need to keep these high-level and low-level classes as loosely coupled as possible. And just for this, we write them dependent on abstractions, and not on each other.</p>
            <div className="columns">
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="Not SOLID">üò≠</span></h4>
                <div>
                  <SnippetL04S11 />
                </div>
              </div>
              <div className="column col-6">
                <h4><span className="tooltip" data-tooltip="SOLID">ü§©</span></h4>
                <div>
                  <SnippetL04S12 />
                </div>
              </div>
            </div>
            <div className="bubble small subtle">
              <p>Let's look at this principle using the example of sending messages. In the first code example, the <code>Notification</code> class is completely dependent on the <code>Email</code> class because it only sends one type of message. What if we want to send in some other way? Then we'll have to dig into the entire messaging system. This is a sign that the system is too tightly coupled.</p>
              <p>To make it loosely coupled in this case, we need to abstract away the <code>Email</code> message send provider. To do this, we create an interface <code>IMessenger</code> with a method <code>Send</code> and implement it in two classes - <code>Email</code> and <code>SMS</code>. We write the <code>Notification</code> class in such a way as to get rid of the specific implementation of the message distribution. In this case, we can use the <strong>Dependency Injection</strong> principle by passing the <code>Messenger</code> object through the constructor. And as a result, we will send messages of the class with which we are currently working. If we create <code>Notification</code> with <code>Email</code> Messenger, an email is sent. Next, we wanted to change the provider and assigned the <code>Messenger</code> properties to the <code>SMS</code> class, so the next call to the <code>Notify</code> method will already send <em>SMS</em>-ku .</p>
            </div>
          </div>
        </li>
      </ul>
      <p>Each <strong>SOLID</strong> principle offers us a way to write logical, reliable, and understandable code, and C#, when followed by these principles, allows you to write large programs and easily extend them.</p>
    </div>
  </li>
</ul>

<ThatsAllFolks />

<div class="bubble">I can talk about C# and .NET for a long time, but in this lecture I shared the main, in my opinion, for you at the moment. That's all, thanks for your attention, rate the lecture in your personal accounts, leave feedback, ask questions, do your homework and see you at the code review! üëã</div>

export default Lecture;
